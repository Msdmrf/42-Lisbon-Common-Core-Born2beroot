# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Evaluation.txt                                     :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: migusant <migusant@student.42lisboa.com    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/05 15:47:11 by migusant          #+#    #+#              #
#    Updated: 2025/05/09 20:19:48 by migusant         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #



The project involves creating and configuring a virtual machine following strict rules. 
The evaluated person will need to assist you during the defense. 
Make sure all the following points are respected.



General Guidelines:

  During the defense, as soon as you need help to verify a point, the evaluated person must assist you:
    1. As a precaution, you may duplicate the original virtual machine to keep a copy.
    2. Check that the "signature.txt" file is present at the root of the cloned repository.
    3. Ensure that the signature contained in "signature.txt" matches that of the ".vdi" file of the virtual machine being evaluated.
    A simple diff should allow you to compare the two signatures. If needed, ask the evaluated person where their ".vdi" file is located.
      Path: 
        /home/migusant/sgoinfre/Born2beroot/Born2beroot.vdi
      Diff Command: 
        diff <(sha1sum /home/migusant/sgoinfre/Born2beroot/Born2beroot.vdi | cut -d' ' -f1) <(cat signature.txt)
      Diff Output:
        If the signatures match, the diff command will produce no output.
        If the signatures do not match, diff will show the lines that differ (i.e., the two different hashes).
    4. Launch the cloned virtual machine to be evaluated.
  If something does not work as expected or the two signatures differ, the evaluation stops here.



Project Overview:

  The evaluated person must simply explain:
    1. The basic functioning of their virtual machine.
      "My virtual machine runs using VirtualBox on my host computer. The hypervisor creates a simulated hardware environment by allocating 
      resources like CPU cores, RAM, and disk space from the host machine. Inside this isolated environment, I have installed and configured 
      the Debian operating system. It functions like a separate computer, but it's entirely contained within the hypervisor software on my host."
    2. Their choice of operating system.
      "I chose Debian primarily because it's the required operating system for the Born2beroot project at 42. Additionally, Debian is well-regarded 
      for its stability, extensive software repositories managed by apt, strong security focus, and its widespread use in server environments. This 
      makes it an excellent platform for learning Linux system administration fundamentals."
    3. The basic differences between Rocky and Debian.
      "The main differences lie in their origins and package management. Rocky Linux is derived from Red Hat Enterprise Linux (RHEL) source code, 
      aiming for binary compatibility with RHEL. It uses the RPM package format and the dnf package manager. Debian is an independent, 
      community-driven project and the base for many other distributions like Ubuntu. It uses the DEB package format and the apt family of package 
      managers (apt, apt-get, aptitude). They also have different philosophies regarding software inclusion and release cycles."
    4. The benefits of virtual machines.
      "Virtual machines offer several key benefits:
        Isolation: They provide a sandboxed environment, separating the guest OS from the host. This is great for testing software or configurations 
        without risking the host system.
        Resource Consolidation: Multiple VMs can run on a single physical machine, making efficient use of hardware resources.
        Snapshots: You can save the state of a VM at any point (a snapshot) and easily revert to it if something goes wrong, which is invaluable for 
        experimentation.
        Testing & Development: VMs allow easy creation of specific, reproducible environments for development or testing software across different OS 
        versions or configurations.
        Portability: VM images can often be moved and run on different physical computers."
    5. If the chosen operating system is Rocky, they must explain what SELinux and DNF are.
      "SELinux, which stands for Security-Enhanced Linux, is a Linux kernel security module that provides a mechanism for supporting Mandatory Access 
      Control (MAC) security policies. Unlike standard Linux Discretionary Access Control (DAC) which relies on user/group ownership and permissions 
      (like rwx), SELinux enforces rules based on policies that define what actions specific processes (subjects) can perform on specific system resources 
      (objects) like files, devices, or network ports. It works by assigning security labels to both subjects and objects. Even if standard file permissions 
      would allow an action, SELinux can block it if the policy doesn't explicitly permit it. This significantly enhances security by limiting the potential 
      damage from compromised processes, preventing privilege escalation, and enforcing fine-grained access control."
      "DNF (Dandified YUM) is the default high-level package manager for Rocky Linux and other modern RPM-based distributions like Fedora and RHEL 8+. It's 
      the successor to yum. DNF is used to install, update, remove, and otherwise manage software packages (in .rpm format) on the system. It automatically 
      handles dependencies, meaning when you install a package, DNF ensures all other required packages are also installed. Compared to yum, DNF offers 
      improved performance, better dependency resolution using the libsolv library, and a more predictable command-line interface."
    6. If the chosen operating system is Debian, they must explain the difference between aptitude and apt, and what APPArmor is. 
      "Both apt and aptitude are high-level package management tools for Debian systems, acting as front-ends to the lower-level dpkg tool.
      apt is the more modern and commonly used command-line interface. It provides essential commands like install, remove, update, upgrade in a 
      straightforward manner.
      aptitude offers both a command-line interface and an interactive text-based UI. Its main advantage is often considered its more sophisticated 
      dependency resolver. 
      When conflicts arise, aptitude can sometimes suggest multiple resolution strategies, whereas apt might be more direct. aptitude also keeps a slightly 
      more detailed log of which packages were installed automatically versus explicitly."
    7. During the defense, a script must display information every 10 minutes. Its operation will be checked in detail later.
      "I have created a monitoring script (monitoring.sh) located at /etc/cron.d/monitoring.sh. I have configured a cron job that executes this script every 
      10 minutes. The script's output, containing various system metrics, is broadcast to all logged-in user terminals using wall. We can check the script's 
      content and the crontab entry later in the evaluation."
  If the explanations are not clear, the evaluation stops here.



Simple Configuration

  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Verify that the machine does not have a graphical environment at startup. A password will be requested before any connection attempt on this machine. 
    Log in with a non-root user. Verify that the chosen password respects the rules imposed in the subject.
      Check User Password: (M1gusant42us3r)
        Your password must be at least 10 characters long. It must contain an uppercase letter, a lowercase letter, and a number. Also, it must not contain 
        more than 3 consecutive identical characters. The password must not include the name of the user.
      Check User Password Extra Policies Command:
        Your password has to expire every 30 days. The minimum number of days allowed before the modification of a password will be set to 2. The user has 
        to receive a warning message 7 days before their password expires.
          sudo chage -l migusant
      Check Log in with Non-Root User Command:
        whoami
      Expected Output:
        migusant
      Check Default Target for System Boot Command:
        systemctl get-default
      Expected Output:
        If we get multi-user.target, it indicates the system boots into a command-line environment.
        If we get graphical.target, it indicates the system is configured to boot into a GUI login manager and desktop. If there is no GUI to boot to, it will boot to a command-line environment.
      Check Graphical Environment Command:
        dpkg -l | grep -E "xserver|gnome|kde|xfce|lxde"
        or
        ls /usr/bin | grep -E "startx|Xorg"
      Expected Output:
        If these commands return results, it means graphical packages are indeed installed.
    2. Then, with the help of the evaluator, make sure that:
      2.1 The chosen operating system is indeed Debian or Rocky.
        OS Command:
          cat /etc/os-release
        Expected Output:
          The output should contain lines clearly identifying the OS as "Debian".
      2.2 The UFW service is properly launched.
        UFW Status Command:
          systemctl status ufw
        Expected Output:
          Active: active (running)
      2.3 The SSH service is properly launched. 
        SSH Service Command:
          systemctl status ssh
        Expected Output:
          Active: active (running)
          Check the port to verify it's listening on the port specified in the subject (e.g., 4242) and not the default port 22.
  If something does not work as expected or is not clearly explained, the evaluation stops here.



User

  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. The subject requires that a user with the login name of the evaluated person be present on the virtual machine. Verify that this user has been added 
    and that they belong to the "sudo" and "user42" groups.
      Check if Belongs Command:
        id migusant or groups migusant
      Expected Output:
        Look for migusant's UID/GID information and verify that both sudo and user42 are listed in the groups= section of the output.
    2. Ensure the rules imposed in the subject concerning the password policy have been implemented by following the steps below.
      2.1 First, create a new user. Assign them a password of your choice, respecting the subject's rules.
        Create user Command:
          sudo adduser testuser
        Create password Command (if not prompted automatically):
          sudo passwd testuser
            If the policy is correctly implemented (e.g., via PAM modules like pam_pwquality), the system should:
              Reject passwords that don't have at lease 10 characters.
              Reject passwords that don't include at lease one uppercase.
              Reject passwords that don't include at lease one lowercase.
              Reject passwords that don't include at lease one digit.
              Reject passwords that include username.
            Eventually accept a password that does meet the criteria.
      2.2 The evaluated person must now explain how they were able to implement the requested rules on their virtual machine.
        "To implement the password policy, I needed to do two different things:
          Password Aging/Expiration: I edited the /etc/login.defs file. Specifically, I set parameters like PASS_MAX_DAYS (e.g., to 30 or 90, as required) 
          to force password changes, PASS_MIN_DAYS (e.g., to 2) to prevent immediate changes, and PASS_WARN_AGE (e.g., to 7) to warn users before expiration.
          Password Strength/Complexity: I installed the libpam-pwquality package (if not present) and configured it by editing the /etc/pam.d/common-password 
          file. I added or modified the line for pam_pwquality.so to include options specified in the subject, such as retry=3 (limit password attempts), 
          minlen=10 (minimum length), dcredit=-1 (at least one digit), ucredit=-1 (at least one uppercase), lcredit=-1 (at least one lowercase), ocredit=-1 
          (at least one special character), and potentially difok=7 (must differ from old password by 7 characters) and reject_username (prevent using username in password)."
  If there is any problem, the evaluation stops here.
    3. Now that you have a new user, ask the evaluated person to create a group named "evaluating" in front of you and assign it to this user.
      Create group Command:
        sudo addgroup evaluating
      Add user to group Command:
        sudo usermod -aG evaluating testuser
      Check if Belongs Command:
        id testuser or groups testuser
      Expected Output:
        Look for testuser's UID/GID information and verify that evaluating is listed in the groups= section of the output.
    4. To finish, ask the evaluated person to explain the purpose of this password policy, as well as the advantages and disadvantages of its implementation. Of course, 
    answering that it is because the subject requires it does not count.
      "The primary purpose of this password policy isn't just because the subject requires it, but to enhance the overall security of the system. It aims to make user accounts 
      significantly harder to compromise through common attacks like brute-forcing (guessing passwords) or using credentials found in breaches (password reuse).
      Some advantages are:
        Increased Security: Complex passwords are much harder to guess or crack. Regular expiration limits the time window an attacker has if they do obtain a password.
        Reduced Risk: Prevents users from using weak, easily guessable passwords or reusing the same password across multiple services.
        Compliance: Helps meet security best practices and potential compliance requirements.
        Accountability: Enforces a minimum standard of security hygiene across all users.
      Some disadvantages are:
        User Inconvenience: Remembering complex passwords and changing them frequently can be frustrating for users.
        Insecure Practices: May lead users to write passwords down (often insecurely) or use predictable patterns to meet complexity rules.
        Potential Lockouts/Helpdesk Load: Users might forget passwords more often, potentially increasing support requests for resets.
        Complexity != Strength: A policy can enforce complexity, but users might still choose fundamentally weak passwords that meet the letter but not the spirit of the rules 
        (e.g., Password123!). It's a balance betweenChange this hostname by replacing the login with yours, then restart the machine. If upon restarting, the hostname has not been updated, the evaluation stops here. technical enforcement and user education."
  If something does not work as expected or is not clearly explained, the evaluation stops here.



Hostname and Partitions

  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Verify that the hostname of the machine is formatted as follows: login42 (login of the evaluated person).
      Check Command:
        hostname
      Expected OUtput:
        migusant42
    2. Change this hostname by replacing the login with yours, then restart the machine. If upon restarting, the hostname has not been updated, the evaluation stops here.
      Wrong change host Command: (This will only change the hostname for the current session. However, this is not persistent across reboots. To make this change persistent see next step.)
        hostname testevaluator
      Check Command:
        hostname
      Right change host Process:
         nano /etc/hostname (change the contents of the file to match the new hostname, for example, to testevaluator)
         nano /etc/hosts    (additionally, update the /etc/hosts file to reflect the new hostname: replace any occurrences of the old hostname with the new one, for example, 127.0.1.1 testevaluator)
         sudo reboot        (restart the machine for the changes to take place)
       Check Command:
        hostname
     3. You can now restore the original hostname of the machine.
       Right change host Process:
        nano /etc/hostname (change the contents of the file to match the old hostname, migusant42)
        nano /etc/hosts    (additionally, update the /etc/hosts file to reflect the new hostname: replace any occurrences of the old hostname with the new one, 127.0.1.1 migusant42)
        sudo reboot        (restart the machine for the changes to take place)
       Check Command:
        hostname
     4. The evaluator will ask you to display the partitions of your virtual machine. To do this, use the following command:
       Check partitions Command:
        lsblk
      Expected Outputs:
        You must have at least 2 encrypted partitions using LVM (check the number of lines below "sdaX_crypt"). Check the subject for an example of the expected partitioning.
        If the evaluatee did the BONUS part, check the example of the expected partitioning from the Bonus Part.
    5. Explanation of LVM:
      "LVM stands for Logical Volume Management. It’s a system for managing disk storage that abstracts the physical layout of the disks. Instead of working directly with physical 
      partitions, LVM introduces an extra layer. Here’s how it works:
      Physical Volumes (PVs): These are the actual physical hard drives or partitions (e.g., /dev/sda2).
      Volume Groups (VGs): These are created by combining one or more physical volumes into a single pool of storage.
      Logical Volumes (LVs): These are created from the volume group and act like virtual partitions. You can format and mount them just like normal partitions.
      For example, you might create a volume group named vg-root and then create logical volumes like lv-root (for /) and lv-swap (for swap space).
      Benefits of LVM:
      Flexibility: You can resize logical volumes dynamically without needing to unmount them (e.g., extend your /home volume if it’s running out of space).
      Snapshots: LVM allows you to create snapshots of logical volumes, which are useful for backups or testing.
      Disk Management: You can add more physical volumes (e.g., new hard drives) to an existing volume group, effectively increasing storage without downtime.
      Simplified Partitioning: LVM allows you to create partitions on-the-fly without worrying about the fixed sizes of traditional partitions."
  If something does not work as expected or is not clearly explained, the evaluation stops here.



SUDO

  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Verify that the "sudo" program is indeed installed on the virtual machine.
      Check Sudo Command:
        sudo --version
      Expected Output:
        Sudo version 1.9.x
    2. Assign your new user (for example, the testuser) to the sudo group:
      Add to Group Command:
        sudo usermod -aG sudo testuser
      Check if Belongs Command:
        id testuser or groups testuser
      Expected Output:
        Look for testuser's UID/GID information and verify that sudo is listed in the groups= section of the output. 
    3. Explain the Purpose and show an example operation of sudo
      "sudo stands for 'superuser do' and allows a user to execute commands with elevated privileges (as the root user). It’s a safer alternative to directly logging 
      in as root because it restricts access and logs all commands executed. By requiring explicit permission and authentication, it minimizes the risk of accidental 
      system-wide changes or malicious actions.
      For example:
      As a user, to update and upgrade the system, you need to use sudo: sudo apt update && sudo apt upgrade.
      As a user, to edit a system file, you need to use sudo: sudo nano /etc/hostname.
      As a user, restart a system service, you need to use sudo: sudo systemctl restart ssh."
    4. Demonstrate the implementation of the rules imposed by the subject, that are present in the "sudoers" file:
      Check sudoers file command:
        sudo visudo
      Defaults        env_reset (clears the environment variables except for a safe default set when running commands with sudo)
        Command:
          Run env, and then sudo env
        Expected Output:
          Observe that most environment variables (like PATH) were reset to a secure default when running sudo env
      Defaults        mail_badpass (sends an email to the system administrator if a user enters an incorrect password for sudo)
        This service isn't installed by default, so you should install it, or defend why don't you use it.
        TO INSTALL IT, CHECK THE mail_logging.sh SCRIPT!
          Commands for mailutils:
            dpkg -l | grep mailutils (if it doesn't return anything, we need to install mailutils)
            sudo apt update
            sudo apt install mailutils -y
          Commands for postfix:
            The mailutils package usually installs Postfix as a dependency, but you'll want to ensure that it is installed and running.
            dpkg -l | grep postfix (if it doesn't return anything, we need to install postfix)
            sudo apt update
            sudo apt install postfix -y
              Select "<OK>"
              Select "Local Only"
              Input your "System mail name: migusant42" and select <OK>
            sudo systemctl start postfix
            sudo systemctl enable postfix
            sudo systemctl status postfix (and check if it is active and running)
            sudo systemctl restart postfix  (to apply new configurations)
          Commands for rsyslog:
            dpkg -l | grep rsyslog (if it doesn't return anything, we need to install rsyslog)
            sudo apt update
            sudo apt install rsyslog -y
            sudo systemctl start rsyslog
            sudo systemctl enable rsyslog
            sudo systemctl status rsyslog (and check if it is active and running)
            sudo systemctl restart rsyslog (to apply new configurations)
            sudo nano /etc/rsyslog.d/mail.conf (open or create the configuration file for mail logs)
            mail.*                        -/var/log/mail.log (add the following line to ensure mail logs are written to /var/log/mail.log)
            sudo systemctl restart rsyslog (save the file and restart the rsyslog service)
            sudo cat /var/log/mail.log (check if the /var/log/mail.log file now exists and contains entries)
            echo "Test mail body" | mail -s "Test Email" root (send a test email)
            sudo cat /var/log/mail.log (check again)
            sudo chmod 640 /var/log/mail.log (verify that /var/log/mail.log has correct ownership)
            sudo chown syslog:adm /var/log/mail.log (verify that /var/log/mail.log has correct permissions)
        Now that is installed, we can test the service.
          Commands for testing:
            ssh migusant@localhost -p 2222 (connect to server via ssh)
            log in to user (check that there is a message saying "You have no new mail.")
            sudo ls (while being the user, but when prompted to put password, fail once, then press CTRL+C)
            logout
            ssh migusant@localhost -p 2222 (connect again to server via ssh)
            log in to user (check that now there is a message saying "You have new mail.")
            mail (check that there is new "*** SECURITY information for migusant42 ***" and the location of it)
            cat /var/mail/migusant (check what happened: "migusant : 1 incorrect password attempt")
      Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" (sets the PATH environment variable for sudo commands to a secure value)
        Commands:
          su - (change to root and insert password)
          echo $PATH
        Expected Output:
          /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      Defaults        requiretty (requires sudo to be run from a terminal (TTY). This prevents scripts from running sudo commands without user interaction)
        Try running a sudo command from a non-interactive context, such as a script:
          Commands:
            ssh migusant@localhost -p 2222 "sudo ls" (this will try to run sudo without allocating a TTY (Teletypewriter))
          Expected Output:
            sudo: sorry, you must have a tty to run sudo
      Defaults        badpass_message="WRONG PASSWORD" (changes the message displayed when a user enters an incorrect password)
        Commands:
          sudo ls (while being the user, but when prompted to put password, fail once, then press CTRL+C)
        Expected Output:
          WRONG PASSWORD
      Defaults        logfile="/var/log/sudo/sudo.log" (specifies a log file where all sudo commands are recorded)
        Commands:
          sudo ls /root (while being the user, to check the content of the root directory)
          sudo tail -n 5 /var/log/sudo/sudo.log (while being the user, to check the last 5 lines of the sudo.log files)
        Expected Output: (find this two lines in the output)
          COMMAND=/usr/bin/ls /root
          COMMAND=/usr/bin/tail -n 5 /var/log/sudo/sudo.log
      Defaults        log_input (log the input of all sudo commands)
      Defaults        log_output (log the output of all sudo commands)
        Run a sudo command that has input and output:
          Command:
            sudo ls /root
            Check the the XX in "TSID=XX" and remember it for the next step (each time you run a sudo command, a unique TSID is assigned to that session)
          Expected Output: 
            The files and directories contained inside the root directory.
          Confirmation: (check the logs in /var/log/sudo/ for both input and output logs)
            su - (change to root to have access to the sudo.log file)            
            ls /var/log/sudo/00/00/XX (here we will have ttyin (the binary related to stdin_log) and ttyout (the binary related to stdout_log))
            sudo sudoreplay /var/log/sudo/00/00/XX (this will replay the session, showing both the input (commands/keystrokes) and the output (command results) as they occurred)
      Defaults        iolog_dir=/var/log/sudo
        Specifies the directory where input/output logs (log_input and log_output) are stored.
          Command:
            ls -ld /var/log/sudo (verifies that the directory exists)
          Expected Output:
           XXXXXXXXXX X root root XXXX MONTH DAY HOUR:MINUTE /var/log/sudo 
          Command:
            cat /var/log/sudo/sudo.log (as we used sudo commands before, check if they were correctly recorded in the sudo.log file)
      Defaults        passwd_tries=3
        Limits the number of incorrect password attempts for sudo to 3.
          Command:
            As user, run: sudo ls (but fail the root password 3 times)
          Expected Output:
            sudo: 3 incorrect password attempts
  If something does not work as expected or is not clearly explained, the evaluation stops here.



UFW / Firewalld
  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Verify that the "UFW" (or "Firewalld" for rocky) program is indeed installed on the virtual machine and that it is functioning correctly:
      UFW Status Command:
        systemctl status ufw (displays whether the UFW service is active (running), inactive (stopped), or failed)
      Expected Output:
         Active: active (exited)
    2. The evaluated person must give you a basic explanation of what UFW (or "Firewalld") is and why it's important to use it:
      "UFW (Uncomplicated Firewall) is a user-friendly frontend for managing iptables (the underlying Linux firewall). It simplifies the process 
      of managing firewall rules and is commonly used on Ubuntu/Debian-based systems. Both UFW and Firewalld help secure servers by controlling 
      inbound and outbound traffic. They allow only specific, trusted connections (e.g., SSH, HTTP/HTTPS) while blocking potentially malicious or 
      unnecessary traffic.A properly configured firewall reduces the attack surface of a server and prevents unauthorized access."
    3. List the active rules in UFW (or "Firewalld"). There should be a rule for port 4242:
      Command:
        sudo ufw status (it determines if UFW is active or inactive and lists the currently configured rules if it's installed.)
      Expected Output:
        Check if there is a rule with the following syntax: 
        "4242                       ALLOW       Anywhere"
    4. Add a new rule to open port 8080 and verify that it has been added by listing the active rules:
      Commands:
        sudo ufw allow 8080
        sudo ufw status
      Expected Output:
        Check if there is are two new rules with the following syntax:
        "8080                       ALLOW       Anywhere"
        "8080 (v6)                  ALLOW       Anywhere (v6)"
    5. Delete this new rule:
      Commands:
        sudo ufw status numbered (used to check the index of the first 8080 rule, let's say that it's number 3)
        sudo ufw delete 3 (say 'y' when prompted to delete the rule with index 3)
        sudo ufw status numbered (used to check the index of the first 8080 rule, let's say that it's number 5)
        sudo ufw delete 5 (say 'y' when prompted to delete the rule with index 5)
      Expected output
        sudo ufw status (this should return the same result as when we used this command in section 3. of "UFW / Firewalld")
  If something does not work as expected or is not clearly explained, the evaluation stops here.



SSH
  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Verify that the SSH service is indeed installed on the virtual machine and that it is functioning correctly:
      SSH Status Command:
        ssh -V (the SSH client is a standalone executable, so running it directly with -V confirms that the client is installed and provides its version)
        systemctl status ssh (displays whether the SSH service is active (running), inactive (stopped), or failed)
      Expected Output:
         Active: active (running)
    2. What SSH is and why it's important to use it:
      "SSH (Secure Shell) is a protocol that allows secure remote access to a server or computer over an encrypted connection. It enables users to execute 
      commands and manage systems remotely while ensuring that data is protected from eavesdropping and tampering. It's important to use because it provides
      a secure way to manage servers, especially for administrators who need to remotely troubleshoot, configure, or monitor systems. It uses encryption
      to protect sensitive information, such as usernames, passwords, and commands."
    3. Verify that the SSH service uses only port 4242:
      Command:
        sudo nano /etc/ssh/sshd_config (sshd_config file should be the one used, since it refers to the "Server-side configuration", and ssh_config to the "Client-side")
      Expected Output:
        Only "Port 4242" should be listed or uncommented.
      Command:
        sudo ss -tuln | grep 4242 (to confirm that SSH is now listening on port 4242)
      Expected Output:
        "tcp   LISTEN 0      128          0.0.0.0:4242      0.0.0.0:*" (related to IPv4 connection)      
        "tcp   LISTEN 0      128             [::]:4242         [::]:*" (related to IPv6 connection)
    4. Use SSH to connect with the new user created:
      Command:
        ssh testuser@localhost -p 2222 (and insert the defined password for testuser)
      Expected Result:
        Successfull login
    5. Ensure that SSH cannot be used with the "root" user as indicated in the subject:
      Command:
        ssh root@localhost -p 2222 (and insert the defined password for root)
      Expected Result:
        "Permission denied, please try again." (beacuse there is a line in /etc/ssh/sshd_config that says "PermitRootLogin no")
  If something does not work as expected or is not clearly explained, the evaluation stops here.



Script Monitoring
  As soon as you need help to verify a point, the evaluated person must be able to assist you:
    1. Display where the monitoring script is located and explain why (if you put it in /etc/cron.d you have to know why is it there and if it is the correct place for it to be)
      "I placed my monitoring.sh script in the /root directory because I wanted to ensure that only the root user could access or modify it. By default, the /root directory is 
      restricted to root, so no other users can even view the script. This adds an extra layer of security, preventing unauthorized changes, especially if someone has limited sudo 
      privileges. Instead of following the guide and placing the script itself in /etc/cron.d, I created a simple monitoring file in that directory. The file contains only the cron 
      job entry: */10 * * * * root bash /root/monitoring.sh | wall 
      This setup allows the script to run every 10 minutes as the root user while keeping the actual script secure in /root. My reasoning is that if the script were in a more accessible 
      location, like /etc/cron.d, someone with sudo access could potentially modify it. By keeping the script in /root, I ensure that only root has control over it. This separation between 
      the script's location and its cron configuration also keeps things modular and easy to manage."
    2. Display the code contained in the monitoring script and explain it
    3. Explain what cron is:
      "Cron is a time-based job scheduler in Unix-like operating systems. It allows users to schedule scripts or commands to execute automatically at specified intervals (e.g., every 10 
      minutes, every day, etc.). Jobs are defined in a file called a crontab (short for "cron table"). Each job in the crontab file specifies: minute, hour, day of the month, month, day 
      of the week, the command or script to execute."
    4. Explain how did you set up their script to execute every 10 minutes from server launch:
      "I created a simple monitoring file in the directory /etc/cron.d because the files in that directory are used for system-wide cron jobs. This is one of the possible locations to save 
      your cron jobs. The monitoring file contains only the cron job entry: 
      */10 * * * * root bash /root/monitoring.sh | wall
      This tells the cron daemon to: run the monitoring.sh script every 10 minutes, execute the script as the root user, use the wall command to broadcast the output to all logged-in users."
    5. Change the cron job to run every minute:
      Command:
        nano /etc/cron.d/monitoring
      Change: "*/10 * * * * root bash /root/monitoring.sh | wall" to "* * * * * root bash /root/monitoring.sh | wall"
      Save:   CTRL+O
      Exit:   CTRL+X
      Wait 1 minute to check that the script runs every minute now.
    6. Modify your script to include a timestamp to show when it runs (this will be the test by adding dynamic values to the script's output)
      Commands:
        # Current Timestamp
        current_time=$(date '+%Y-%m-%d %H:%M:%S')
        printf "#Current Time: %s\n\n" "$current_time"
      Expected Output:
        Check for the line "#Current Time: YEAR-MONTH-DAY HOUR:MINUTE:SECOND"
    7. Modify the cronjob script to disable running the script at reboot (without changing the script place, its permissions, and its content):
      Commands:
        su -
        ls -l /root/monitoring.sh (to ensure that after the last reboot, the permissions of the script remain the same)
        nano /etc/cron.d/monitoring
        #@reboot root sleep 15 && bash /root/monitoring.sh | wall (comment this option to disable running the script when booting the machine)
        reboot (to ensure that the script no longer runs at server launch)
        ls -l /root/monitoring.sh (to ensure that after the last reboot, the permissions of the script remained the same)
  If any of the above points are not correct, the evaluation stops here.



Bonus
  Bonuses will only be examined if the mandatory part is excellent. This means that the mandatory part must have been completed from start to finish, with perfect error management even 
  in cases of unexpected use. If all mandatory points have not been awarded during this defense, no bonus points will be counted.
    1. The implementation of partitions will be worth 2 points:
      Disk Partitions
        /boot (sda1): Contains the bootloader (e.g., GRUB) and kernel files required to boot the system. It is a separate partition to ensure the bootloader can access the files, even if the rest of the disk is encrypted (which is the case here). Typically mounted as /boot.
        sda2: This is most likely a placeholder partition created automatically by the partitioning tool. It is often used for special purposes, such as aligning partitions or as a reserved partition.
        sda5: This is the main partition that contains a LUKS-encrypted volume (sda5_crypt). The encrypted partition ensures all data stored on the disk is secure.
        sda5_crypt: This is the encrypted partition that protects the data stored within it. Inside this partition, Logical Volume Management (LVM) is used to create flexible and manageable sub-partitions (logical volumes).
      Logical Volumes Inside sda5_crypt
        / (Root) (migusant42--vg-root): This is the root partition, which contains the operating system files, binaries, libraries, and essential system data. It is the core of the Linux system.
        /var     (migusant42--vg-var): Contains variable files such as logs, cached data, and spool files (e.g., print jobs or mail queues). Isolated to prevent large log files from filling up the entire root partition.
        [SWAP]   (migusant42--vg-swap_1): Swap space is used as virtual memory when the system's RAM is fully utilized. It allows the system to temporarily move inactive data from RAM to disk, freeing up memory for active processes.
        /tmp     (migusant42--vg-tmp): Temporary files are stored here, such as files generated during program execution or downloads-in-progress. Isolated to ensure temporary data doesn’t affect other parts of the system.
        /home    (migusant42--vg-home): Stores user-specific files like documents, downloads, and configuration files. Keeping /home separate makes it easier to back up and manage user data.
        /srv     (migusant42--vg-srv): Used to store data for server-specific applications (e.g., web server files, FTP data). This separation ensures server data is organized and does not interfere with other parts of the system.
        /var/log (migusant42--vg-var--log): Dedicated to storing system logs (e.g., system events, application logs). Isolating log files prevents them from filling up the /var partition, which would otherwise affect services.
      Other Devices
        sr0: used for external media like installation disks.
      "This partitioning scheme is good in terms of:
      Security: The use of LUKS encryption (sda5_crypt) ensures that all data is protected, even if the disk is physically stolen.
      Organization: Separating partitions like /var, /tmp, /home, and /srv ensures that different types of data are isolated. For example: /var prevents logs from filling up / and /home keeps user data separate from system files.
      Performance: Using LVM allows for dynamic resizing and efficient management of storage space.
      Reliability: Isolating critical directories (like /var/log) ensures that a single directory filling up will not crash the entire system."
    2. The setup of WordPress, with only the services listed in the subject (lighttpd, MariaDB, and PHP), will be worth 2 points:
      Lighttpd
        What is lighttpd?
          "Lighttpd (pronounced "lighty") is a lightweight, high-performance web server designed for speed, security, and minimal resource usage. It is particularly suitable for serving 
          static and dynamic web content on resource-constrained environments."
        How is it used in this project?
          "In this project, lighttpd is used as the web server to host the WordPress website. It serves the WordPress content to users; processes PHP requests using the FastCGI module 
          (mod_fastcgi), which communicates with PHP-FPM to handle dynamic requests; is configured to use /var/www/html/wordpress as the document root, allowing WordPress files to be 
          served to clients; enforces security configurations, such as disabling directory listing and restricting access to sensitive files (like wp-config.php)."
      MariaDB
        What is MariaDB?
          "MariaDB is a popular open-source relational database management system (RDBMS) that is a fork of MySQL. It is widely used for storing, retrieving, and managing structured data 
          in databases. MariaDB is known for its high performance, scalability, and compatibility with MySQL."
        How is it used in this project?
          "In this project, MariaDB is used as the database backend for WordPress. It stores all WordPress data, including posts, pages, user accounts, comments, and settings; hosts a 
          dedicated database named wordpress, created specifically for this project; uses a restricted database user (wp_user) with a strong password to access only the WordPress database; 
          ensures data security by running mysql_secure_installation to remove unnecessary features like test databases and enabling a strong root password."
      PHP
        What is PHP?
          "PHP (Hypertext Preprocessor) is a server-side scripting language designed for web development. It is particularly well-suited for embedding within HTML and is widely used to 
          create dynamic web applications."
        How is it used in this project?
          "In this project, PHP serves as the engine for processing WordPress’s dynamic content. It enables WordPress to interact with the MariaDB database, retrieve content, and render 
          pages dynamically; runs as a FastCGI application via PHP-FPM, which communicates with lighttpd to handle PHP requests; includes essential PHP modules such as php-mysql (for 
          database connectivity), php-curl, php-gd, and others to ensure full compatibility with WordPress."
      WordPress
        What is WordPress?
          "WordPress is a free and open-source content management system (CMS) used to create and manage websites. It is highly customizable, offering themes, plugins, and a user-friendly 
          interface for building websites without extensive coding."
        How is it used in this project?
          "In this project, WordPress is the core platform for the website. It provides an interface for creating and managing web content (e.g., posts, pages, media); utilizes the MariaDB 
          database for storing content and configuration data; runs on the lighttpd web server and uses PHP to dynamically render pages and handle backend logic; is installed in the /var/www/html/wordpress 
          directory and configured with proper permissions to ensure security and functionality."
    3. Test the WordPress website and its services (lighttpd, MariaDB, and PHP):
      Lighttpd
        3.1.1 Verify if the lighttpd Service is Running
          Command:
            sudo systemctl status lighttpd
          Expected Output:
            active (running)
        3.1.2 Test if lighttpd is Serving Static Files
          Commands:
            echo "Lighttpd is working!" | sudo tee /var/www/html/test.html
            curl http://10.0.2.15/test.html (the 10.0.2.15 is my server-ip, yours can be different)
          Expected Output:
            Lighttpd is working!
        3.1.3 Check lighttpd Logs for Errors
          Command:
            sudo tail -f /var/log/lighttpd/error.log
          Expected Output:
            The logs should not contain recurring errors or warnings.
        3.1.4 Test PHP Integration with lighttpd
          Commands:
            echo "<?php print_r(get_loaded_extensions()); ?>" | sudo tee /var/www/html/info.php
            curl http://10.0.2.15/info.php
          Expected Output:
            Verify that required extensions like mysqli, curl, gd and mbstring are installed.
        3.1.5 Check lighttpd Configuration
          Command:
            sudo lighttpd -t -f /etc/lighttpd/lighttpd.conf
          Expected Output:
            Syntax OK
      MariaDB
        3.2.1 Verify if the MariaDB Service is Running
          Command:
            sudo systemctl status lighttpd
          Expected Output:
            active (running)
        3.2.2 Access MariaDB
          Command:
            mariadb
          Expected Output:
            Welcome to the MariaDB monitor.
        3.2.3 Create New Database and User, and Change Privileges:
          Create new database
            Commands:
              SHOW DATABASES; (to check the existing databases)
              CREATE DATABASE testuser_db
              SHOW DATABASES; (to check again)
            Expected Output:
              The databases table has changed
          Create new user
            Commands:
              SELECT user, host FROM mysql.user; (to check the existing users)
              CREATE USER testuser@localhost;
              SELECT user, host FROM mysql.user; (to check again)
            Expected Output:
              The user table has changed
          Grant user control over that database
            Commands:
              SHOW GRANTS FOR testuser@localhost; (check user privileges before)
              GRANT ALL PRIVILEGES ON testuser_db.* TO testuser@localhost;
              FLUSH PRIVILEGES; (apply changes)
              SHOW GRANTS FOR testuser@localhost; (check again)
            Expected Output:
              The user privileges have changed
          Exit database editor
            Command:
              EXIT;
        3.2.4 Test Connection to the User Database
          Command:
            mysql -u testuser -p testuser_db (leave the password blank when prompted and press ENTER)
          Expected Output:
            MariaDB [testuser_db]> (you should be logged into the testuser_db database directly)
          Command:
            EXIT;
        3.2.5 Check the WordPress Database Tables
          Commands:
            mysql -u migusant -p migusant_db (leave the password blank when prompted and press ENTER)
            MariaDB [migusant_db]> SHOW TABLES;
          Expected Output:
            +-----------------------+
            | Tables_in_wordpress   |
            +-----------------------+
            | wp_comments          |
            | wp_links             |
            | wp_options           |
            | wp_postmeta          |
            | wp_posts             |
            | wp_term_relationships|
            | wp_term_taxonomy     |
            | wp_terms             |
            | wp_usermeta          |
            | wp_users             |
            +-----------------------+
        3.2.6 Test Writing to the Database
          Commands:
            USE migusant_db;
            CREATE TABLE test_table (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100));
            INSERT INTO test_table (name) VALUES ('MariaDB Test');
            SELECT * FROM test_table;
          Expected Output:
            +----+--------------+
            | id | name         |
            +----+--------------+
            |  1 | MariaDB Test |
            +----+--------------+
          Commands:
            DROP TABLE test_table; (to drop the created test_table)
            EXIT; (to exit mariadb editor)
        3.2.7 Check MariaDB Logs for Errors
          Command:
            sudo journalctl -u mariadb (this checks for any errors or warnings from MariaDB)
          Expected Output:
            No recurring errors or issues should appear in the logs.
      PHP (less tests are needed since we already tested some while testing the lighttpd service)
        3.3.1 Verify PHP Installation
          Commands:
            php -v (to check the PHP version)
            php -m (to check the list of all installed PHP modules)
          Expected Installed Modules:
            php          -> General PHP functionality (required for all PHP-based services)
            php-pdo      -> MariaDB (for database abstraction, works with PDO)
            php-mysql    -> MariaDB (to connect PHP to MariaDB/MySQL databases)
            php-zip      -> WordPress (used for managing plugins, themes, and backups in ZIP format)
            php-gd       -> WordPress (image manipulation for themes, plugins, and media uploads)
            php-mbstring -> WordPress (multibyte string support for non-ASCII text and multi-language websites)
            php-curl     -> WordPress (for HTTP requests, APIs, and remote connections)
            php-xml      -> WordPress (used for XML parsing, RSS feeds, and web services)
            php-pear     -> General PHP functionality (provides reusable PHP components and tools)
            php-bcmath   -> WordPress (for high-precision math operations, often used in plugins like WooCommerce)
            php-opcache  -> General PHP functionality (improves PHP performance by caching precompiled scripts)
            php-json     -> WordPress (for encoding/decoding JSON, essential for APIs and modern web applications)
            php-cgi      -> General PHP functionality (enables PHP to run as a CGI script, required for FastCGI integration with lighttpd)
        3.3.2 Check PHP-FPM Logs
          Command:
            sudo journalctl -u php* (this checks for any errors or warnings from php service)
          Expected Output:
            No recurring errors or issues should appear in the logs.
      WordPress
        3.4.1 Check the Homepage
          URL:
            http://127.0.0.1:2904/
          Expected Output:
            You should see your WordPress homepage.
        3.4.2 Access the Admin Dashboard
          URL:
            http://127.0.0.1:2904/wp-admin (log in with your WordPress admin credentials)
          Expected Output:
            If the admin panel loads successfully, your WordPress installation is working as expected.
        3.4.3 Check WordPress Functionality: Test Creating a Post
          Actions:
            Go to Posts > Add New in the admin panel.
            Create a test post by adding a title and some content.
            Publish the post and view it on the frontend.
            Verify that the post appears correctly.
        3.4.4 Check WordPress Functionality: Test Media Uploads
          Actions:
            Go to Media > Add New in the admin panel.
            Upload an image or file.
            Check if the file uploads without errors and is accessible from the Media Library.
        3.4.5 Check WordPress Functionality: Test Plugin Installation
          Actions:
            Go to Plugins > Add New in the admin panel.
            Search for a plugin (e.g., "Hello Dolly") and install it.
            Activate the plugin and check if it works as expected.
        3.4.6 Check WordPress Functionality: Test Theme Functionality
          Actions:
            Go to Appearance > Themes in the admin panel.
            Switch to another theme (e.g., Twenty Twenty-Three).
            Visit the site to ensure the new theme is applied correctly.
    4. The free-choice service will be worth 1 point. Verify and test the proper functioning and implementation of each additional service. For the free-choice bonus service, the evaluated person 
    must provide a simple explanation of the service and explain the reasons for their choice. Be aware: NGINX and Apache2 are forbidden.
      Docker
        What is Docker?
          "Docker is an open-source platform designed to automate the deployment, scaling, and management of applications using lightweight, portable containers. These containers bundle the application 
          code, runtime, libraries, and dependencies into an isolated environment, ensuring consistency across different systems."
        How is it used in this project?
          "In this project, Docker is used to simplify the deployment and management of the additional service. For example: a Docker container can be set up to run a specific service (e.g., Redis, 
          Elasticsearch, or a custom application) without worrying about dependency conflicts on the host system; Docker Compose is used to manage multiple containers, making it easy to start, stop, and 
          configure services with a single command; the additional service is packaged into its own container, ensuring that it runs consistently and independently of the underlying operating system."
        Why was Docker your choice for the additional service?
          "I chose Docker because it’s going to be a key tool in future projects. I wanted to use this project as a foundation to familiarize myself with Docker installation, configuration, and management. 
          While I didn’t use Docker to run a specific container in this project, setting it up has given me a basis for understanding how it works and how we’ll use it in the future.
          Also, I chose it because after 42 I want to follow cybersecurity, and Docker is highly relevant to cybersecurity for several reasons, two of them being Isolation, and Sandboxing. Isolation because 
          Docker containers provide strong isolation between applications and their environments. This reduces the risk of vulnerabilities in one service affecting others on the same host. Sandboxing because 
          Docker containers are often used to run untrusted code in a sandboxed environment. This is useful for analyzing malware or testing potentially harmful software without compromising the host system."
    5. Test the Docker additional service:
      Docker
        Command:
          docker run hello-world
        Expected Output:
          Hello World!
        

